/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Stm32_F103C6_Drivers/inc/stm32f103x6.h"
#include "../Stm32_F103C6_Drivers/inc/stm32F103C6_GPIO_Driver.h"
#include "../Stm32_F103C6_Drivers/inc/stm32_F103C6_EXTI_Driver.h"
#include "../HAL/inc/keypad.h"
#include "../HAL/inc/lcd.h"


#define TaskA_Stack_Size				100		//100 bytes
#define TaskB_Stack_Size				100		//100 bytes

#define OS_SET_PSP(address)				__asm volatile ("mov r0, %[in0] \n\t MSR PSP, r0": :[in0] "r" (address))

#define OS_Generate_Exception			__asm volatile ("SVC #0x3")

#define OS_SWITCH_SP_TO_MSP				__asm volatile ("MRS r3, CONTROL \n\t and r3, r3, #0x5 \n\t MSR CONTROL, r3")
#define OS_SWITCH_SP_TO_PSP				__asm volatile ("MRS r3, CONTROL \n\t ORR r3, r3, #0x2 \n\t MSR CONTROL, r3")

#define OS_SwitchCPU_Privileged			__asm volatile ("MRS r3, CONTROL \n\t LSR r3, r3, #1 \n\t LSL r3, r3, #1 \n\t MSR CONTROL, r3")
#define OS_SwitchCPU_Unprivileged		__asm volatile ("MRS r3, CONTROL \n\t ORR r3, r3, #0x1 \n\t MSR CONTROL, r3")		//write

extern int _estack;

uint8_t TaskA_Flag, TaskB_Flag, clearFlag =0;

unsigned int _S_MSP = (unsigned int)&_estack;
unsigned int _E_MSP ;

//task A
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

//task B
unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;


void Switch_CPU_AccessLevel (enum CPU_AccessLevel_e Level);
void MainOS(void);
void Switch_Stack (enum Stack_e Stack);
int Task_A (int a, int b, int c);
int Task_B (int a, int b, int c , int d);

void SVC_Handler (void)
{
	OS_SwitchCPU_Privileged;
}

void EXTI9_CallBack (void)
{
	//	clearFlag = 1;
	TaskA_Flag = 0;
	TaskB_Flag = 0;

	if (clearFlag==0)
	{
		TaskA_Flag = 1;
		clearFlag = 1;
	}
	else
	{
		TaskB_Flag = 1;
		clearFlag=0;
	}

}


int main(void)
{
	//CLK Enable
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	EXTI_PinConfig_t EXTI_Config ;

	EXTI_Config.EXTI_PIN = EXTI9PB9;
	EXTI_Config.IRQ_EN = EXTI_IRQ_ENABLE;
	EXTI_Config.Trigger_Case = EXTI_Trigger_Rising;
	EXTI_Config.P_IRQ_CallBack = EXTI9_CallBack;

	MCAL_EXTI_GPIO_Init(&EXTI_Config);


	MainOS ();
	/* Loop forever */
	for(;;)
	{
		if (clearFlag==1)
		{
			clearFlag=0;
		}
	}
}


int Task_A (int a, int b, int c)
{
	return a+b+c;
}

int Task_B (int a, int b, int c , int d)
{
	return a+b+c+d;
}

void MainOS(void)
{
	//Main Stack
	_E_MSP = _S_MSP - 512;

	//Task A Stack
	_S_PSP_TA = _E_MSP - 8;
	_E_PSP_TA = _S_PSP_TA - TaskA_Stack_Size;

	//Task B Stack
	_S_PSP_TB = _E_PSP_TA - 8 ;
	_E_PSP_TB = _S_PSP_TB - TaskB_Stack_Size;

	uint32_t result=0;

	while (1)
	{
		__asm("nop");
		if (TaskA_Flag == 1)
		{
			//1-set PSP Register to _S_PSP_TA
			OS_SET_PSP(_S_PSP_TA);

			//2- SP --> PSP
			OS_SWITCH_SP_TO_PSP;

			//3- switch to unprivileged
			OS_SwitchCPU_Unprivileged;

			result= Task_A(3, 3, 3);

			//4- switch to privileged
			OS_Generate_Exception;

			//5- SP --> MSP
			OS_SWITCH_SP_TO_MSP;
		}
		else if (TaskB_Flag== 1)
		{
			//1- set PSP Register to _S_PSP_TB
			OS_SET_PSP(_S_PSP_TB);

			//2- SP --> PSP
			OS_SWITCH_SP_TO_PSP;

			//3- switch to unprivileged
			OS_SwitchCPU_Unprivileged;

			result = Task_B(2, 2, 2, 2);

			//4- switch to privileged
			OS_Generate_Exception;

			//5- SP --> MSP
			OS_SWITCH_SP_TO_MSP;
		}
	}
}
